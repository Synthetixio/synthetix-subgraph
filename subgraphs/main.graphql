"""
 THIS FILE IS AUTOMATICALLY GENERATED BY THE DEPLOY SCRIPT
"""
type SynthByCurrencyKey @entity {
  " currency key "
  id: ID!
  proxyAddress: Bytes!
}

type Synth @entity {
  " lowercase address of the proxy contract for the synth "
  id: ID!
  name: String!
  symbol: String!
  totalSupply: BigDecimal!
}

type SynthBalance @entity {
  " timestamp + account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

" we dont query this entity but only use it to store aggregate data we need during syncing "
type LatestSynthBalance @entity {
  " account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

" Tracks this event from the Synthetix.sol contract "
type SynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

" Tracks this event from the Synthetix.sol contract. (Atomic exchanges also trigger standard SynthExchange events.)"
type AtomicSynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

type Total @entity {
  " $timestamp-$period-$bucketMagnitude-$synth "
  id: ID!
  " timestamp of the beginning of the time period this represents "
  timestamp: BigInt!
  " number of seconds the data covers after `timestamp` "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " number of trades completed over period "
  trades: BigInt!
  " number of unique traders who were first seen in this period "
  newExchangers: BigInt!
  " number of unique traders seen over period "
  exchangers: BigInt!
  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

" An individual Exchanger aggregated by various time groupings "
type Exchanger @entity {
  " hex address in lowercase (and for non global: hex address in lowercase-$timestamp-$period-$bucketMagnitude-$synth "
  id: ID!
  " timestamp of the beginning of the time period this represents, or 0 for no period filter "
  timestamp: BigInt!
  " number of seconds the data covers after `timestamp`, or 0 for no period filter "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " when the user first exchanged "
  firstSeen: BigInt!
  " when the user last exchanged "
  lastSeen: BigInt!
  " nubmer of trades by account "
  trades: BigInt!
  " synth value exchanged in USD units by account "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units from account "
  totalFeesGeneratedInUSD: BigDecimal!
}

type LatestRate @entity {
  " Name of synth. E.g. sUSD "
  id: ID!
  " Synth USD rate "
  rate: BigDecimal!
  " Address of the aggregator which produces current result "
  aggregator: Bytes!
  " Timestamp the rate was updated "
  timestamp: BigInt!
}

" Latest Rates over time "
type RateUpdate @entity {
  " <transaction hash>-<currency key> "
  id: ID!
  " currencyKey for which this this rate update applies "
  currencyKey: Bytes!
  " currencyKey expressed as a string "
  synth: String!
  " the rate recorded at this timestamp "
  rate: BigDecimal!
  " the block which this rate was recorded "
  block: BigInt!
  " timestamp of the block in which the rate was recorded "
  timestamp: BigInt!
}

type Candle @entity {
  " synth-period-periodId (periodId is timestamp / period) "
  id: ID!
  " Ticker for synth (e.g. 'sUSD') or 'SNX'"
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  average: BigDecimal!
  timestamp: BigInt!
  " Duration this candle captures in seconds. Year, quarter, month, week, day, hour, and 15 minutes available. "
  period: BigInt!
  " Number of RateUpdates aggregated into this candle, mostly useful for the indexer to calculate averages "
  aggregatedPrices: BigInt!
}

type Account @entity {
  "NFT token id"
  id: ID!
  owner: Bytes!
  created_at: BigInt!
  created_at_block: BigInt!
  updated_at: BigInt!
  updated_at_block: BigInt!
  permissions: [AccountPermissionUsers!]
}

type AccountPermissionUsers @entity {
  "NFT token id + user address"
  id: ID!
  address: Bytes!
  account: Account!
  permissions: [Bytes!]!
  created_at: BigInt!
  created_at_block: BigInt!
  updated_at: BigInt!
  updated_at_block: BigInt!
}

type OrderSettled @entity {
  id: ID!
  timestamp: BigInt!
  marketId: BigInt!
  accountId: BigInt!
  account: Account!
  orderCommitted: OrderCommitted
  fillPrice: BigInt!
  accruedFunding: BigInt!
  sizeDelta: BigInt!
  newSize: BigInt!
  totalFees: BigInt!
  referralFees: BigInt!
  collectedFees: BigInt!
  settlementReward: BigInt!
  trackingCode: Bytes!
  settler: Bytes!
  pnl: BigInt!
  txnHash: String!
}

type OrderCommitted @entity {
  id: ID!
  timestamp: BigInt!
  marketId: BigInt!
  accountId: BigInt!
  account: Account!
  orderType: Int!
  sizeDelta: BigInt!
  acceptablePrice: BigInt!
  commitmentTime: BigInt!
  expectedPriceTime: BigInt!
  settlementTime: BigInt!
  expirationTime: BigInt!
  trackingCode: Bytes!
  sender: Bytes!
  txnHash: String!
}

type PendingOrder @entity {
  id: ID!
  orderCommittedId: String!
}

type PerpsV3Position @entity {
  id: ID!
  openTimestamp: BigInt!
  closeTimestamp: BigInt
  timestamp: BigInt!
  marketId: BigInt!
  marketSymbol: String!
  accountId: BigInt!
  account: Account!
  isOpen: Boolean!
  isLiquidated: Boolean!
  totalTrades: BigInt!
  totalVolume: BigInt!
  size: BigInt!
  realizedPnl: BigInt!
  totalReducedNotional: BigInt!
  feesPaid: BigInt!
  netFunding: BigInt!
  pnlWithFeesPaid: BigInt!
  entryPrice: BigInt!
  avgEntryPrice: BigInt!
  lastPrice: BigInt!
  exitPrice: BigInt
}

type OpenPerpsV3Position @entity {
  id: ID!
  position: PerpsV3Position
}

type PerpsV3Market @entity {
  id: ID!
  marketName: String!
  marketSymbol: String!
  lastPrice: BigInt!
}

type SettlementStrategy @entity {
  id: ID!
  strategyId: BigInt!
  marketId: BigInt!
  enabled: Boolean!
  strategyType: Int!
  settlementDelay: BigInt!
  settlementWindowDuration: BigInt!
  priceVerificationContract: String!
  feedId: Bytes!
  settlementReward: BigInt!
  commitmentPriceDelay: BigInt!
}

type FundingRateUpdate @entity {
  id: ID!
  timestamp: BigInt!
  marketId: BigInt!
  fundingRate: BigInt!
  marketName: String!
  marketSymbol: String!
  market: Bytes!
  marketKey: Bytes!
  asset: Bytes!
  sequenceLength: BigInt!
  funding: BigInt!
}

type FundingRatePeriod @entity {
  id: ID!
  timestamp: BigInt!
  fundingRate: BigInt!
  marketName: String!
  marketSymbol: String!
  period: FundingRatePeriodType!
  marketKey: Bytes!
  asset: Bytes!
}

enum FundingRatePeriodType {
  Hourly
  Daily
}

type DelegatedAccount @entity {
  id: ID!
  caller: Bytes!
  delegate: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type CollateralChange @entity {
  id: ID!
  synthId: BigInt!
  accountId: BigInt!
  sender: Bytes!
  timestamp: BigInt!
  amountDelta: BigInt!
  txHash: String!
}

type PerpsV3Stat @entity {
  id: ID!
  accountId: BigInt!
  accountOwner: Bytes!
  feesPaid: BigInt!
  pnl: BigInt!
  pnlWithFeesPaid: BigInt!
  liquidations: BigInt!
  totalTrades: BigInt!
  totalVolume: BigInt!
}

type PerpsV3AggregateStat @entity {
  id: ID!
  period: BigInt!
  timestamp: BigInt!
  marketId: BigInt!
  marketSymbol: String!
  trades: BigInt!
  volume: BigInt!
}

type PnlSnapshot @entity {
  id: ID!
  accountId: BigInt!
  pnl: BigInt!
  timestamp: BigInt!
}

type MarketPriceUpdate @entity {
  id: ID!
  timestamp: BigInt!
  marketId: BigInt!
  price: BigInt!
}

type PositionLiquidation @entity {
  id: ID!
  accountId: BigInt!
  timestamp: BigInt!
  marketId: BigInt!
  amount: BigInt!
  notionalAmount: BigInt!
  estimatedPrice: BigInt!
}

type FuturesMarket @entity {
  id: ID!
  asset: Bytes!
  marketKey: Bytes!
  marketStats: FuturesCumulativeStat!
}

type FuturesTrade @entity {
  id: ID!
  timestamp: BigInt!
  account: Bytes!
  abstractAccount: Bytes!
  accountType: FuturesAccountType!
  margin: BigInt!
  size: BigInt!
  asset: Bytes!
  marketKey: Bytes!
  price: BigInt!
  positionId: ID!
  positionSize: BigInt!
  positionClosed: Boolean!
  pnl: BigInt!
  feesPaid: BigInt!
  fundingAccrued: BigInt!
  keeperFeesPaid: BigInt!
  orderType: FuturesOrderType!
  trackingCode: Bytes!
}

type FuturesPosition @entity {
  id: ID!
  lastTxHash: Bytes!
  openTimestamp: BigInt!
  closeTimestamp: BigInt
  timestamp: BigInt!
  market: Bytes!
  asset: Bytes!
  marketKey: Bytes!
  account: Bytes!
  abstractAccount: Bytes!
  accountType: FuturesAccountType!
  isOpen: Boolean!
  isLiquidated: Boolean!
  trades: BigInt!
  totalVolume: BigInt!
  size: BigInt!
  initialMargin: BigInt!
  margin: BigInt!
  pnl: BigInt!
  feesPaid: BigInt!
  netFunding: BigInt!
  pnlWithFeesPaid: BigInt!
  netTransfers: BigInt!
  totalDeposits: BigInt!
  fundingIndex: BigInt!
  entryPrice: BigInt!
  avgEntryPrice: BigInt!
  lastPrice: BigInt!
  exitPrice: BigInt
}

type FuturesStat @entity {
  id: ID!
  account: Bytes!
  feesPaid: BigInt!
  pnl: BigInt!
  pnlWithFeesPaid: BigInt!
  liquidations: BigInt!
  totalTrades: BigInt!
  totalVolume: BigInt!
  smartMarginVolume: BigInt!
}

type FuturesCumulativeStat @entity {
  id: ID!
  totalLiquidations: BigInt!
  totalTrades: BigInt!
  totalTraders: BigInt!
  totalVolume: BigInt!
  averageTradeSize: BigInt!
}

type FuturesAggregateStat @entity {
  id: ID!
  period: BigInt!
  timestamp: BigInt!
  marketKey: Bytes!
  asset: Bytes!
  trades: BigInt!
  volume: BigInt!
  feesKwenta: BigInt!
  feesSynthetix: BigInt!
  feesCrossMarginAccounts: BigInt!
}

type FuturesMarginTransfer @entity {
  id: ID!
  timestamp: BigInt!
  account: Bytes!
  market: Bytes!
  asset: Bytes!
  marketKey: Bytes!
  size: BigInt!
  txHash: String!
}

type FuturesMarginAccount @entity {
  id: ID!
  timestamp: BigInt!
  account: Bytes!
  market: Bytes!
  asset: Bytes!
  margin: BigInt!
  deposits: BigInt!
  withdrawals: BigInt!
}

type FundingPayment @entity {
  id: ID!
  timestamp: BigInt!
  account: Bytes!
  positionId: ID!
  marketKey: Bytes!
  asset: Bytes!
  amount: BigInt!
}

enum FuturesOrderType {
  NextPrice
  Limit
  StopMarket
  Market
  Liquidation
  Delayed
  DelayedOffchain
}

enum FuturesPriceOracleUsed {
  PYTH
  CHAINLINK
}

enum FuturesOrderStatus {
  Pending
  Open
  Filled
  Cancelled
}

enum FuturesAccountType {
  isolated_margin
  smart_margin
}

type FuturesOrder @entity {
  id: ID!
  size: BigInt!
  marketKey: Bytes!
  account: Bytes!
  txnHash: Bytes!
  abstractAccount: Bytes!
  orderId: BigInt!
  targetPrice: BigInt!
  marginDelta: BigInt!
  timestamp: BigInt!
  orderType: FuturesOrderType!
  status: FuturesOrderStatus!
  keeper: Bytes!
  reduceOnly: Boolean
  priceOracle: FuturesPriceOracleUsed
}

type SmartMarginAccount @entity {
  id: ID!
  owner: Bytes!
  version: Bytes!
}

type SmartMarginAccountTransfer @entity {
  id: ID!
  account: Bytes!
  abstractAccount: Bytes!
  timestamp: BigInt!
  size: BigInt!
  txHash: String!
}

type SmartMarginOrder @entity {
  id: ID!
  account: Bytes!
  orderType: FuturesOrderType!
  marketKey: Bytes!
  recordTrade: Boolean!
  feesPaid: BigInt!
}

type PerpsTracking @entity {
  id: ID!
}

type CrossMarginAccountTransfer @entity {
  id: ID!
  account: Bytes!
  abstractAccount: Bytes!
  timestamp: BigInt!
  size: BigInt!
  txHash: String!
}

type CrossMarginAccount @entity {
  id: ID!
  owner: Bytes!
}

enum PeriodEnumType {
  DAILY
}

type HistoricalMarketStats @entity {
  id: Bytes!
  timestamp: BigInt
  marketKey: Bytes
  marketAsset: Bytes
  period: PeriodEnumType
  marketSize: BigInt
}
