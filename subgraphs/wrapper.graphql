type Wrapper @entity {
  " wrapper address "
  id: ID!

  " address of wrapped token, empty if ETH"
  tokenAddress: String!

  " the current amount of synths minted by this wrapper"
  amount: BigDecimal!

  " the current amount of synths minted by this wrapper in USD"
  amountInUSD: BigDecimal!

  " the maximum amount of synths that can be minted by this wrapper"
  maxAmount: BigDecimal!

  " the currency key of this wrapper "
  currencyKey: String!

  " the total amount of fees generated by this wrapper "
  totalFees: BigDecimal!

  " the total amount of fees generated by this wrapper in USD"
  totalFeesInUSD: BigDecimal!
}

type WrapperMint @entity {
  " the transaction hash with a log index appended "
  id: ID!

  " address of the user minting "
  account: String!

  " amount of synth minted "
  principal: BigDecimal!

  " amount of fees collected "
  fee: BigDecimal!

  " total amount added to the wrapper "
  amountIn: BigDecimal!

  " the timestamp of the block that includes this event "
  timestamp: BigInt!

  " the address of the wrapper that minted this synth "
  wrapperAddress: String!
}

type WrapperBurn @entity {
  " the transaction hash with a log index appended "
  id: ID!

  " address of the user burning "
  account: String!

  " amount of synth burned "
  principal: BigDecimal!

  " amount of fees collected "
  fee: BigDecimal!

  " total amount removed from the wrapper "
  amountOut: BigDecimal!

  " the timestamp of the block that includes this event "
  timestamp: BigInt!

  " the address of the wrapper that burned this synth "
  wrapperAddress: String!
}

" we dont query this entity but only use it to store aggregate data we need during syncing "
type InversePricingInfo @entity {
  " Name of inverse synth. E.g. iETH "
  id: ID!

  " whether or not this inverse synth has been frozen "
  frozen: Boolean!

  " configured upper limit "
  upperLimit: BigDecimal!

  " configured lower limit "
  lowerLimit: BigDecimal!

  " matching price point with long synth "
  entryPoint: BigDecimal!
}

type LatestRate @entity {
  " Name of synth. E.g. sUSD "
  id: ID!

  " Synth USD rate "
  rate: BigDecimal!

  " Address of the aggregator which produces current result "
  aggregator: Bytes!
}

" Latest Rates over time "
type RateUpdate @entity {
  " <transaction hash>-<currency key> "
  id: ID!
  " currencyKey for which this this rate update applies "
  currencyKey: Bytes!
  " currencyKey expressed as a string "
  synth: String!
  " the rate recorded at this timestamp "
  rate: BigDecimal!
  " the block which this rate was recorded "
  block: BigInt!
  " timestamp of the block in which the rate was recorded "
  timestamp: BigInt!
}

type Candle @entity {
  " synth-period-periodId (periodId is timestamp / period) "
  id: ID!
  " Ticker for synth (e.g. 'sUSD') or 'SNX'"
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  average: BigDecimal!
  timestamp: BigInt!
  " Duration this candle captures in seconds. Year, quarter, month, week, day, hour, and 15 minutes available. "
  period: BigInt!
  " Number of RateUpdates aggregated into this candle, mostly useful for the indexer to calculate averages "
  aggregatedPrices: BigInt!
}

" DEPRECATED: See the Candles entity"
type DailyCandle @entity {
  " DEPRECATED: See the Candles entity "
  id: ID!
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  timestamp: BigInt!
}
